# lab5.md

## 代码总结

semaphore的需要在tck中增加一个`allocation`变量，记录每个task已获得的信号量，由sys_semaphore_up和sys_semaphore_down维护。算法所需的其余变量都在sys_semaphore_down()期间计算得到。

## 问答题

当主线程（0 号线程）退出时，需要回收以下资源：

1. **线程栈**：每个线程都有自己的栈空间，主线程退出时需要释放这些栈空间。
2. **线程控制块（Task Control Block, TCB）**：每个线程的状态和上下文信息存储在 TCB 中，需要回收这些数据结构。
3. **锁和同步原语**：所有被线程持有的锁和其他同步原语（如信号量、条件变量）需要被释放。
4. **文件和资源句柄**：所有线程持有的文件描述符和其他资源句柄需要关闭。

`TaskControlBlock` 可能被以下位置引用：

1. **调度队列**：调度器维护的队列中可能包含对线程 TCB 的引用。这些引用需要回收，因为线程已经终止。
2. **等待队列**：如果线程在等待某个资源（如锁、条件变量），它的 TCB 可能在等待队列中。这些引用也需要回收。
3. **其他线程**：其他线程可能持有某些线程的 TCB 的引用，用于线程间通信或同步。如果主线程退出，这些引用需要处理以防止悬挂引用（Dangling References）。

所有这些引用需要回收，因为线程已经退出，保留这些引用会导致内存泄漏或悬挂引用问题。

- `Mutex1`：无论 `wait_queue` 是否有任务，都会在解锁后设置 `locked = false`。实现更容易理解，但在任务唤醒和锁释放的时机上可能会出现问题，导致锁状态不一致，进而引发死锁问题。
- `Mutex2`：只有当 `wait_queue` 为空时，才会设置 `locked = false`。实现更为谨慎，但在某些情况下可能会导致任务等待队列中有任务等待时，锁没有被正确释放的问题。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

1. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

https://blog.csdn.net/weixin_44246009/article/details/108548948

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
