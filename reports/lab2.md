# 编程作业

## 重写 sys_get_time 和 sys_task_info

逐页copy数据。其余代码逻辑基本不变。

## mmap 和 munmap 匿名映射

为每个 `mmap()` 调用创建一个`MapArea`,push到当前进程的memory_set中。如果[start, start + len) 中存在已经被映射的页，映射已被映射的页时将返回错误。`munmap()`从当前进程的memory_set中查找对应的`map_area`并删除，同时`unmap`

# 问答作业

1. SV39页表项63位用于`Svnapot`拓展，62-61位用于`Svpbmt` 拓展，60-54位保留，53-10为页号，9-0为标志位。

V(Valid)：仅当位 V 为 1 时，页表项才是合法的；

R(Read)/W(Write)/X(eXecute)：当全为0时代表指向下一级页表,否则指向叶页表，并控制索引到这个页表项的对应虚拟页面是否允许读/写/执行，

U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；

G: 指示后续的页表是'global',用于提升性能；

A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；

D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过。

2. 缺页
  1. 可能由缺页导致的异常包括:Instruction(12)/Load(13)/Store/AMO(15) page fault
  2. CSR寄存器:
    - scause: 中断/异常发生时， CSR 寄存器 scause 中会记录其信息， Interrupt 位记录是中断还是异常， Exception Code 记录中断/异常的种类a。
    - sstatus: 记录处理器当前状态，其中 SPP 段记录当前特权等级。
    - stvec: 记录处理 trap 的入口地址，现有两种模式 Direct 和 Vectored 。
    - sscratch: 其中的值是指向hart相关的S态上下文的指针，比如内核栈的指针。
    - sepc: trap 发生时会将当前指令的下一条指令地址写入其中，用于 trap 处理完成后返回。
    - stval: trap 发生进入S态时会将异常信息写入，用于帮助处理 trap ，其中会保存导致缺页异常的虚拟地址。
  3. Lazy 策略可提升性能。 
  4. 对应的 SV39 页表占用内存 = 20MB+40KB+80B
  5. 在分配内存时，可先不进行实际分配，仅将其记录下来。当发生访问缺页情况时，会触发缺页异常，在`trap handler`中处理相应的异常，此时再进行内存的加载或分配即可。
  6. 页面失效表现为PTE的V标志位为0
3. 双页表与单页表
  1. 将当前用户进程的satp保存到对应内核栈中，再将下一个用户进程的satp对应内核栈中读取到satp.
  2. 将内核页面的 pte 的`U`标志位设置为0
  3. 在内核和用户态之间转换时不需要更换页表，也就不需要跳板。
  4. 双页表实现下用户程序和内核转换时、用户程序转换时都需要更换页表。

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
